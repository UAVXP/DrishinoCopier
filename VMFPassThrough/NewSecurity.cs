using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Management;
using System.Net.NetworkInformation;
using System.IO;

namespace VMFPassThrough
{
#if !PUBLIC
	class NewSecurity : AsrctOne
	{
		private static string[] ids = new string[] {
			// Here goes hardware IDs generated by NewSecurity.GetMachineID()
		};
		private static List<string> allowedMachineIDs = new List<string>(ids);

		public static string GetMachineID()
		{
			// Getting CPU ID
			string cpuInfo = string.Empty;
			try
			{
				ManagementClass mc = new ManagementClass("win32_processor");
				ManagementObjectCollection moc = mc.GetInstances();
				foreach (ManagementObject mo in moc)
				{
					if (cpuInfo == "")
					{
						//Get only the first CPU's ID
						cpuInfo = mo.Properties["processorID"].Value.ToString();
						break;
					}
				}
				moc.Dispose();
				mc.Dispose();
			}
			catch { }

			// Getting motherboard ID
			string mbInfo = string.Empty;
			try
			{
				ManagementScope scope = new ManagementScope("\\\\" + Environment.MachineName + "\\root\\cimv2");
				scope.Connect();
				ManagementObject wmiClass = new ManagementObject(scope, new ManagementPath("Win32_BaseBoard.Tag=\"Base Board\""), new ObjectGetOptions());

				foreach (PropertyData propData in wmiClass.Properties)
				{
					if (propData.Name == "SerialNumber")
					{
					//	mbInfo = String.Format("{0,-25}{1}", propData.Name, Convert.ToString(propData.Value));
						mbInfo = Convert.ToString(propData.Value);
					}
				}
			//	Console.WriteLine(mbInfo);
				wmiClass.Dispose();
			}
			catch { }

			// Getting MAC address
			string macInfo = string.Empty;
			try
			{
				IPGlobalProperties computerProperties = IPGlobalProperties.GetIPGlobalProperties();
				NetworkInterface[] nics = NetworkInterface.GetAllNetworkInterfaces();
				//	if (nics == null || nics.Length < 1)
				//	{
				//		Console.WriteLine("  No network interfaces found.");
				//	}
				foreach (NetworkInterface adapter in nics)
				{
					if (adapter.NetworkInterfaceType != NetworkInterfaceType.Ethernet)
						continue;

					if (macInfo == "")
					{
						IPInterfaceProperties properties = adapter.GetIPProperties(); //  .GetIPInterfaceProperties();
						PhysicalAddress address = adapter.GetPhysicalAddress();
						byte[] bytes = address.GetAddressBytes();
						for (int i = 0; i < bytes.Length; i++)
						{
							// Display the physical address in hexadecimal.
							//	Console.Write("{0}", bytes[i].ToString("X2"));
							//	macInfo += bytes[i].ToString("X2");
							macInfo += bytes[i].ToString();
						}
					//	Console.WriteLine(macInfo);
						break;
					}
				}
			}
			catch { }

			// Getting disk drive ID
			string volumeSerial = string.Empty;
			try
			{
				string drive = Path.GetPathRoot(Environment.GetFolderPath(Environment.SpecialFolder.System)).TrimEnd('\\').TrimEnd(':'); // Getting main system drive letter
				ManagementObject dsk = new ManagementObject(@"win32_logicaldisk.deviceid=""" + drive + @":""");
				dsk.Get();
				volumeSerial = dsk["VolumeSerialNumber"].ToString();
				dsk.Dispose();
			}
			catch { }

			string currentMachineID = String.Format("{0}-{1}-{2}-{3}", cpuInfo, volumeSerial, mbInfo, macInfo);
			currentMachineID = MD5Checksum(currentMachineID);
			Console.WriteLine(currentMachineID);
			return currentMachineID;
		}

		public static bool IsMachineAllowed()
		{
			if (allowedMachineIDs.IndexOf(GetMachineID()) >= 0)
				return true;

			if (allowedMachineIDs.IndexOf(Security.GetMachineID()) >= 0) // Compatibility with an old method
				return true;

			if (allowedMachineIDs.IndexOf(MD5Checksum(Security.GetMachineID())) >= 0)
				return true;

			return false;
		}
	}
#endif
}
